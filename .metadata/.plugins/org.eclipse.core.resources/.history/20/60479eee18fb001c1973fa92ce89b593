package com.skillstorm;

import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Properties;
import java.util.Set;

import com.skillstorm.javabeans.Employee;

public class ExpenseDao {
	
	//instance variables are NOT thread safe
	private Connection connection;
	
	
	public ExpenseDao() throws SQLException {
		
		Properties props = new Properties();
		
		InputStream in = ClassLoader.getSystemResourceAsStream("application.properties");
		
		try {
			props.load(in);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		String url = props.getProperty("database.url");
		String username = props.getProperty("database.username");
		String password = props.getProperty("database.password");
		
		this.connection = DriverManager.getConnection(url, username, password);
	}

	//we need out CRUD statements
	public boolean createEmployeeRecord(Employee employee)
	{
		String sql = "insert into expense(name, reason, notes)values(?,?,?)";
		
		/*
		 * create a sql statement the question marks represent code that will be filled
		 * in safely with the prepared statement
		 */
		String sql = "insert into expense(name, reason, notes)values(?,?,?);";
		String name = "wanda";
		String reason = "lost items";
		String notes = "cant find my stapler and hole puncher";
		
		/*
		 * we will use this interface to create a statement that will send our sql to
		 * database.  this will create a statementImpl object in memory. 
		 * factory method design pattern
		 * polymorphism 
		 *	the challenge is that we allow the user to
		 * potentially hurt us with sql injection 
		 * prepared statement creates
		 * paramaterized sql statements to avoid command injection
		 */		
		PreparedStatement statement = connection.prepareStatement(sql);
		
		/*
		 * set string means were setting the SQL string to replace the ? for SOME reason
		 * the index of ? a string array starts at 1 each ? needs a value or it wont
		 * compile
		 */
		statement.setString(1, name);
		statement.setString(2, reason);
		statement.setString(3, notes);
		
		statement.executeUpdate();
	}
	
	//set is good so we dont have duplicates
	public Set<Employee> findAll()
	{
		//all this exceptions says is our methods not ready to be used
		throw new UnsupportedOperationException("still working on it");
	}
	
	public Employee findById(int id) 
	{
		throw new UnsupportedOperationException("still working on it");
	}
	
	public boolean deleteRecord(int id)
	{
		throw new UnsupportedOperationException("still working on it");
	}
	
	public boolean UpdateRecord(Employee employee) 
	{
		throw new UnsupportedOperationException("still working on it");
	}
	
}
